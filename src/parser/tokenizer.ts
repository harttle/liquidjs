import { whiteSpaceCtrl } from './whitespace-ctrl'
import { Substr } from './substr'
import { FilterArg } from './filter-arg'
import { FilterToken } from './filter-token'
import { ellipsis } from '../util/underscore'
import { HTMLToken } from './html-token'
import { TagToken } from './tag-token'
import { Token } from './token'
import { OutputToken } from './output-token'
import { TokenizationError } from '../util/error'
import { NormalizedFullOptions, defaultOptions } from '../liquid-options'

// bitmask character types to boost performance
// generated by bin/char-types.js
const TYPES = '00000000044004000000000000000000428000080000010011111111110022210111111111111111111111111110000101111111111111111111111111100000'
const VARIABLE = 1
const OPERATOR = 2
const BLANK = 4
const QUOTE = 8

export class Tokenizer {
  private p = 0
  private N: number
  private line = 1
  private col = 1
  constructor (
    private input: string,
    private file: string = '',
    private options: NormalizedFullOptions = defaultOptions
  ) {
    this.N = input.length
  }

  * readExpression (): IterableIterator<string> {
    while (this.p < this.N) {
      const operand = this.readValue()
      if (operand.size()) {
        yield operand.toString()
        continue
      }
      this.readBlank()
      const operator = new Substr(this.input, this.p)
      while (OPERATOR & this.peekType()) operator.end = this.read()
      if (operator.size()) {
        yield operator.toString()
        continue
      }
      this.read()
    }
  }

  readFilterTokens (): FilterToken[] {
    const filters = []
    while (true) {
      const filter = this.readFilterToken()
      if (!filter) return filters
      filters.push(filter)
    }
  }

  // | foo
  // | foo: a
  // | foo: a, b
  // | foo: a, b: 1
  readFilterToken (): FilterToken | null {
    this.readTo('|')
    const begin = this.p
    const name = this.readVariable().toString()
    if (!name) return null
    const args = []
    this.readBlank()
    if (this.peek() === ':') {
      do {
        this.read()
        const arg = this.readFilterArg()
        arg && args.push(arg)
        while (this.p < this.N && this.peek() !== ',' && this.peek() !== '|') this.read()
      } while (this.peek() === ',')
    }
    const raw = this.input.slice(begin, this.p)
    return new FilterToken(name, args, raw, this.input, this.line, this.col, this.file)
  }

  readFilterArg (): FilterArg | null {
    const key = this.readValue()
    if (!key) return null
    this.readBlank()
    if (this.peek() === ':') {
      this.read()
      return [key.toString(), this.readValue().toString()]
    }
    return key.toString()
  }

  readTokens (): Token[] {
    const tokens: Token[] = []
    while (this.p < this.N) {
      const token = this.readToken()
      tokens.push(token)
    }
    whiteSpaceCtrl(tokens, this.options)
    return tokens
  }

  readToken (): Token {
    const { tagDelimiterLeft, outputDelimiterLeft } = this.options
    if (this.matchWord(tagDelimiterLeft)) return this.readTagToken()
    if (this.matchWord(outputDelimiterLeft)) return this.readOutputToken()
    return this.readHTMLToken()
  }

  readHTMLToken (): HTMLToken {
    const html = new Substr(this.input, this.p)
    while (this.p < this.N) {
      const { tagDelimiterLeft, outputDelimiterLeft } = this.options
      if (this.matchWord(tagDelimiterLeft)) break
      if (this.matchWord(outputDelimiterLeft)) break
      html.end = this.read()
    }
    return new HTMLToken(html.toString(), this.input, this.line, this.col, this.file)
  }

  readTagToken (): TagToken {
    const { line, col, file, input, options } = this
    const { tagDelimiterLeft, tagDelimiterRight } = options
    const buffer = this.readTo(tagDelimiterRight).toString()
    if (!this.reverseMatchWord(tagDelimiterRight, buffer)) {
      throw new TokenizationError(
        `tag "${ellipsis(buffer, 16)}" not closed`,
        new Token(buffer, input, line, col, file)
      )
    }
    const value = buffer.slice(tagDelimiterLeft.length, -tagDelimiterRight.length)
    return new TagToken(buffer, value, input, line, col, options, file)
  }

  readOutputToken (): OutputToken {
    const { line, col, file, input, options } = this
    const { outputDelimiterLeft, outputDelimiterRight } = options
    const buffer = this.readTo(outputDelimiterRight).toString()
    if (!this.reverseMatchWord(outputDelimiterRight, buffer)) {
      throw new TokenizationError(
        `output "${ellipsis(buffer, 16)}" not closed`,
        new Token(buffer, input, line, col, file)
      )
    }
    const value = buffer.slice(outputDelimiterLeft.length, -outputDelimiterRight.length)
    return new OutputToken(buffer, value, input, line, col, options, file)
  }

  readVariable (): Substr {
    this.readBlank()
    const ans = new Substr(this.input, this.p)
    while (this.peekType() & VARIABLE) ans.end = this.read()
    return ans
  }

  readHashes () {
    const hashes = []
    while (true) {
      const hash = this.readHash()
      if (!hash) return hashes
      hashes.push(hash)
    }
  }

  readHash () {
    this.readBlank()
    if (this.peek() === ',') this.read()
    const name = this.readVariable().toString()
    if (!name) return null

    this.readBlank()
    let value = ''
    if (this.peek() === ':') {
      this.read()
      value = this.readValue().toString()
    }
    return [name, value]
  }

  readPropertyAccess (): Substr {
    this.readBlank()
    const ans = new Substr(this.input, this.p)
    let nested = 0
    while (this.p < this.N) {
      const c = this.peek()
      const code = this.peekType()
      if (c === '[') {
        this.read()
        ans.end = this.readValue().end
        nested++
      } else if (c === ']') {
        if (!nested) break
        ans.end = this.read()
        nested--
      } else if (c === '.') {
        if (this.peekType(1) & VARIABLE) {
          this.read()
          ans.end = this.readVariable().end
        } else break
      } else if (code & VARIABLE) {
        ans.end = this.read()
      } else {
        if (nested) this.read()
        else break
      }
    }
    return ans
  }
  readTo (end: string): Substr {
    const ans = new Substr(this.input, this.p)
    while (this.p < this.N) {
      ans.end = this.read()
      if (this.reverseMatchWord(end)) break
    }
    return ans
  }
  readValue (): Substr {
    let val = this.readQuoted()
    if (val.size()) return val
    val = this.readBoolean()
    if (val.size()) return val
    val = this.readPropertyAccess()
    if (val.size()) return val
    return this.readRange()
  }
  readRange (): Substr {
    this.readBlank()
    const ans = new Substr(this.input, this.p)
    if (this.peek() !== '(') return ans
    this.read()
    this.readValue()
    this.read(2)
    this.readValue()
    ans.end = this.read()
    return ans
  }
  readBoolean (): Substr {
    this.readBlank()
    const ans = new Substr(this.input, this.p)
    if (this.matchWord('true') && !(this.peekType(4) & VARIABLE)) ans.end = this.read(4)
    else if (this.matchWord('false') && !(this.peekType(5) & VARIABLE)) ans.end = this.read(5)
    return ans
  }
  readQuoted (): Substr {
    this.readBlank()
    const ans = new Substr(this.input, this.p)
    if (!(this.peekType() & QUOTE)) return ans
    ans.end = this.read()
    let escaped = false
    while (this.p < this.N) {
      ans.end = this.read()
      if (ans.last() === ans.first() && !escaped) break
      if (escaped) escaped = false
      else if (ans.last() === '\\') escaped = true
    }
    return ans
  }
  read (n = 1): number {
    if (n > 1) this.read(n - 1)
    const c = this.input[this.p++]
    if (c === '\n') {
      this.line++
      this.col = 1
    } else {
      this.col++
    }
    return this.p
  }
  matchWord (word: string) {
    for (let i = 0; i < word.length; i++) {
      if (word[i] !== this.input[this.p + i]) return false
    }
    return true
  }
  reverseMatchWord (word: string, buffer?: string) {
    const str = buffer || this.input
    const end = buffer === undefined ? this.p : buffer.length
    for (let i = 0; i < word.length; i++) {
      if (word[word.length - 1 - i] !== str[end - 1 - i]) return false
    }
    return true
  }
  peekType (n = 0) {
    return +TYPES[this.input.charCodeAt(this.p + n)]
  }
  peek (n = 0) {
    return this.input[this.p + n]
  }
  readBlank () {
    let ans = ''
    while (this.peekType() & BLANK) ans += this.read()
    return ans
  }
}
